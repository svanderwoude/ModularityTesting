\documentclass[twoside]{uva-inf-bachelor-thesis}
%\usepackage[dutch]{babel}

% Filling your thesis with only lorem ipsum is not advised.
\usepackage{lipsum}
\usepackage{todonotes}
\usepackage{cite}
\usepackage{amsmath}
\usepackage{float}
\usepackage[toc,page]{appendix}

\newcommand{\myparagraph}[1]{\paragraph{#1}\mbox{}\\}

% Title Page
\title{The effect of modularity on software quality}
\author{Stefan van der Woude}
\supervisors{dr. A.M. Oprescu}
\signedby{Signees}

\begin{document}
\maketitle

\begin{abstract}

\end{abstract}

\tableofcontents


\chapter{Introduction}
\todo{Remove time references everywhere}
Creating high quality software is often very difficult, and becomes even harder when the size increases. Over the years, many standards and guidelines have been developed to provide general definitions and rules for software. Examples of this are the Don't Repeat Yourself (DRY) concept, cyclomatic complexity metric and test coverage measurements. Even though there are in many cases clear quantitative guidelines for these values and concepts, they are hard to strictly follow in complex programs.\\

If we look at a more general view of software, we get to the field of software design. Software design is the process by which an agent creates a specification of a software artifact, intended to accomplish goals, using a set of primitive components and subject to constraints. One of these design techniques is modular programming, which we will analyze in this thesis. Modular programming emphasizes separating the functionality of a program into independent, interchangeable modules, such that each contains everything necessary to execute only on aspect of the desired functionality. In this paper a method of measuring the degree of modularity of a program is developed, after which a set of programs is tested on different quality characteristics, including modularity.

\section{Research questions}
The goal of this research is to find if there is a relation between the degree of modularity of a program and the quality of that program. Using the tests described above we will be able to get an overview of the effect of modularity on the different quality characteristics. The research question is answered is as follows:

\[ \text{"What is the effect of modularity on the quality of software?"} \]

In order to answer this question, a few other questions have to be answered. Since we have to define the degree of modularity of programs, we will have to answer the question "How can we easily and effectively calculate the degree of modularity of a program?". After this question has been answered, we have to find methods for measuring all (sub-) quality characteristics used to define the quality of software. Thus, for each characteristic we have to find an answer to the question "How can we measure [quality attribute] of a program?". The answers to these questions will create a framework to perform measurements on a program, after which the main research question can be answered.

\section{Research methodology}
This research uses a quantitative approach. Experiments are done using existing literature and new ideas in order to generate data which can be used for statistical analysis. Using this analysis we will be able to see if there is a relation between the modularity and quality of software.

\section{Thesis outline}
\todo[inline]{Do this once all other content is done to prevent incorrect information}

\chapter{Background}
Writing good code is something you are taught to achieve from the day you start learning programming. Code quality is often seen as something really important, it assures that the software is maintainable and fast. Quality could be seen as not having any bad practices in your code base, since one might think that will improve the maintainability of the code. However, research has shown that these code smells do not necessarily have a negative (nor a positive) effect on maintainability\cite{sjoberg2013quantifying}. Something that might be of interest when looking at maintainability is consistency within the code. Together with code size, this might improve the readability and analysability of software.

\section{Software design}
One way to force some level of consistency within a program is the use of a software design pattern. These patterns, or techniques, describe the design of the design: how will the program be structured? Edsger W. Dijkstra referred to this layering of semantic levels as the "radical novelty" of computer programming\cite{dijkstra1988}. Using, and strictly following, a software design pattern allows for easier analysability and maintainability since it creates a clear structure that is repeated in numerous places. In this thesis we focus on the Modular Programming design technique.

\subsection{Modular programming}
Modular programming is a software design technique that emphasizes separating the functionality of a program into independent, interchangeable modules, such that each contains everything necessary to execute only one aspect of a desired functionality. Not all programming languages formally support the concept of modules, languages like C\#\cite{csharpmodules}, Java\cite{javamodules} and Python\cite{pythonmodules} do.\\

In 1975 Fred Brooks observed that there is a positive correlation between the size of an organization and the delay in time to market, we call this Brooks' Law \cite{brooks1975mythical}. Brooks argued that adding more programmers to a software project that is already at a late stage of the development process further delays the project. He reasoned that the complexity and communication cost of a project increase with the square of the number of developers, but the amount of work done only rises linearly \cite{lee2000linux}.\\

This problem also occurred in the development of the Linux Kernel, which is an open source project \cite{LinuxKernel}. In 1996 the creator, Linus Torvalds, decided to move towards a modular software architecture which would allow him to set boundaries within which the developers of each module have full control over implementation and design details. This architecture countered Brooks' Law and allowed a large group of people to develop a computer program jointly. Torvalds stated that "without modularity, I would have to check every file that changed, which would be a lot, to make sure nothing was changed that would affect anything else. With modularity, when someone sends me patches to do a new file system and I don't necessarily trust the patches per se, I can still trust the fact that if nobody's using this file system, it's not going to impact anything else." \cite{lee2000linux}. Another study, on the Apache and Mozilla projects, also showed that high modularity (together with many bug finders and fixers) resulted in low defect densities and allowed for faster development.\\

\myparagraph{What is a module?}
Formally, a module is seen as a self-contained piece of software that contains everything necessary to execute only one aspect of a more broad functionality.\\

It is worth noting that even though the languages above support modules, the official definition can still differ per language. For example, in Python each file is seen as a module, while in Java a module is a collection of packages. Thus, even though all languages use the same general definition of a module, the scale of the term varies between them.

\myparagraph{Characteristics of modules}
Since a module is a self-contained piece of software, it is important that it has as few dependencies to other software as possible. The degree of interdependence between modules is called coupling, which should be low in the case of a perfect module. Since there are almost no dependencies to other modules, it is important that the module itself can perform its functionality itself. Making sure that all functionality within the module is tied together and belongs to each other is a second requirement of the ideal module. We refer to the degree to which elements inside a module belong together as cohesion, which should be high in the case of a perfect module.\\

Besides these main characteristics of modules, on could also argue that another characteristic of a module is that it is a part of software that can be reused in multiple conditions, which would mean that a single function could also be seen as a (small-scale) module. In this thesis we will stick with the original characteristics to do measurements.

\section{Software quality}
Software quality might be somewhat an opinion, it strongly depends on your own interpretation of a program. However, in 2011, the International Organization for Standardization released the ISO/IEC 25010 - 'System and software quality models' standard\cite{ISO25010} which defines a set of models and characteristics to test software quality. This standard is a successor to the ISO/IEC 9126 - 'Product quality - Quality model' standard\cite{ISO9126} released in 2001.

\subsection{ISO/IEC 25010}
The ISO/IEC 25010 standard defines eight characteristics that can be evaluated when looking at the quality of a piece of software. Some of these relate to the outcome of interaction when a product is used in a particular context of use, others relate to the static properties of software and dynamic properties of the computer system it is used in. The full list of characteristics and their sub-characteristics is listed below.

\subsection{Compatibility}
The first quality characteristic is compatibility. Compatibility is referred to as the degree to which a product, system or component can exchange information with other products, systems or components, and/or perform its required functions, while sharing the same hardware or software environment. We can divide this into two sub-characteristics: co-existence and interoperability. In our research we will not look at this characteristic since it is not likely to be affected by modularity.

\myparagraph{Co-existence}
The first sub-characteristic is co-existence. Co-existence is the degree to which a product can perform its required functions efficiently while sharing a common environment and resources with other products without detrimental impact on any other product.

\myparagraph{Interoperability}
The interoperability of two or more systems, products or component defines the degree to which they can exchange information and use the information that can be exchanged.

\subsection{Functional suitability}
The second quality characteristic is functional suitability, this characteristic defines the degree to which a product or system provides functions that meet stated and implied needs when used under specified conditions. This characteristic consists of three sub-characteristics: functional appropriateness, functional completeness and functional correctness. We will not look at the functional suitability of our test programs since the functionality does not rely on the modularity of a program.

\myparagraph{Functional appropriateness}
The functional appropriateness of a system defines the degree to which the set of functions facilitate the accomplishment of specified tasks and objectives.

\myparagraph{Functional completeness}
The second sub-characteristic defines the degree to which the set of functions in a system covers all the specified tasks and user objectives. We call this the functional completeness of a product or system.

\myparagraph{Functional correctness}
The functional completeness of a product or system defines the degree to which it provides the correct results with the needed degree of precision.

\subsection{Maintainability}
The next characteristic, after functional suitability, is maintainability. Whilst maintainability could be evaluated differently per person, there are some aspects of a program that can be measured to determine the maintainability of a program. In this case we refer to maintainability as the degree of effectiveness and efficiency with which a product or system can be modified to improve it, correct it, or adapt to changes in environment, and in requirements. This characteristic consists of four aspects. We will look at the relation between modularity and maintainability since the software design method of a system can have effect on the maintainability of the system.

\myparagraph{Analysability}
Analysability is the degree of effectiveness and efficiency with which it is possible to assess the impact on a product or system of an intended change to one or more of its parts, or to diagnose a product for deficiencies or causes of failures, or to identify parts to be modified.

\myparagraph{Modifiability}
The second sub-characteristic, modifiability, is referred to as the degree to which a product or system can be effectively and efficiently modified without introducing defects or degrading existing product quality.

\myparagraph{Modularity}
Whilst we are looking at the effect of modularity on the quality of software, ISO/IEC 25010 already considers this to have an effect on the maintainability of a product or system.

\myparagraph{Re-usability}
With re-usability, we refer to the degree to which an asset can be used in more than one system, or in building other assets.

\myparagraph{Testability}
The final sub-characteristic of maintainability is testability. Testability defines the degree of effectiveness and efficiency with which test criteria can be established for a system, product or component and tests can be performed to determine whether those criteria have been met.

\subsection{Performance efficiency}
The fourth characteristic, performance efficiency, presents the performance relative to the amount of resources used under stated conditions. This means that three components of performance and resources have to be tested. Performance efficiency is likely to be affected by the modularity of a program, though it might not be much. We will look at the relation between modularity and performance efficiency to support this.

\myparagraph{Capacity}
The first component is capacity, capacity is defined as the degree to which the maximum limits of a product or system parameter meets the requirements. We will ignore this sub-characteristic since the capacity of a program is arbitrary.

\myparagraph{Resource utilization}
Next, performance efficiency contains the sub-characteristic resource utilization. With resource utilization we mean the degree to which the amounts and types of resources used by a product or system, when performing its functions, meet the requirements.

\myparagraph{Time behavior}
The final component to look at is the degree to which the response and processing times and throughput rates of a product or system, when performing its functions, meet the requirements. We refer to this as the time behavior of a product or system.

\subsection{Portability}
The next characteristic defines the degree of effectiveness and efficiency with which a system, product or component can be transferred from one hardware, software or other operational or usage environment to another. We call this characteristic the portability of a system, product or component. When defining the portability, we can look at three different sub-characteristics: adaptability, installability and replaceability. Even though portability might be influenced by the modularity of a system, we will not look at this characteristic in this research due to the importance of others.

\myparagraph{Adaptability}
With adaptability, we refer to the degree to which a product or system can effectively and efficiently be adapted for different or evolving hardware, software or other operation or usage environments.

\myparagraph{Installability}
The second sub-characteristic defines the degree of effectiveness and efficiency with which a product or system can be successfully installed and/or uninstalled in a specified environment. We refer to this as the installability of a product or system.

\myparagraph{Replaceability}
The final sub-characteristic, replaceability, defines the degree to which a product can replace another specified product for the same purpose in the same environment.

\subsection{Reliability}
The next quality characteristic is reliability. With reliability we refer to the degree to which a system, product or component performs specified functions under specified conditions for a specified period of time. We can split this into four smaller characteristics. The reliability of a system does not depend on the software design used, thus we shall not look at the relation between the modularity and reliability of a program.

\myparagraph{Availability}
With availability we refer to the degree to which a system, product or component is operational and accessible when required for use.

\myparagraph{Fault tolerance}
The second characteristic defines the degree to which a system, product or component operates as intended despite the presence of hardware or software faults. We call this characteristic the fault tolerance of a system, product or component.

\myparagraph{Maturity}
The next sub-characteristic is maturity. Maturity is defined as the degree to which a system, product or component meets needs for reliability under normal operation.

\myparagraph{Recoverability}
The final sub-characteristic, recoverability, defines the degree to which, in event of an interruption or failure, a product or system can recover the data directly affected and re-establish the desired state of the system.

\subsection{Security}
The seventh quality characteristic defines the degree to which a product or system protects information and data so that persons or other products or systems have the degree of data access appropriate to their types and levels of authorization. We call this characteristic security. This can in turn be divided into five sub-characteristics such as confidentiality and integrity. Modularity does not have an effect on the security measures implemented in a piece of software, therefore we will ignore this characteristic in this research.

\myparagraph{Accountability}
The first sub-characteristic is accountability. Accountability shows the degree to which the actions of an entity can be traced uniquely to the entity.

\myparagraph{Authenticity}
Next up we define the degree to which the identity of a subject or resource can be proven to be the one claimed. We refer to this as authenticity.

\myparagraph{Confidentiality}
In a product or system, confidentiality is very important. The confidentiality of a product or system defines the degree to which it ensures that data is accessible only to those authorized to have access.

\myparagraph{Integrity}
The degree to which a system, product or component prevents unauthorized access to, or modification of, computer programs or data is referred to as integrity, which is the fourth sub-characteristic of security.

\myparagraph{Non-repudiation}
The final sub-characteristic is non-repudiation. This characteristic defines the degree to which actions or events can be proven to have taken place, so that events or actions cannot be repudiated later.

\subsection{Usability}
The final characteristic in the ISO 25010 standard is usability. Usability defines the degree to which a product or system can be used by specified users to achieve specified goals with effectiveness, efficiency and satisfaction in a specified context of use. We can split this into the six sub-characteristics defined below. This characteristic mainly depends on the User Experience of a program, since we will not cover this topic we will not look if there is a relation between modularity and User Experience.

\myparagraph{Accessibility}
The first sub-characteristic is accessibility. With accessibility we define the degree to which a product or system can be used by people with the widest range of characteristics and capabilities to achieve a specified goal in a specified context of use.

\myparagraph{Appropriateness recognizability}
The degree to which users can recognize whether a product or system is appropriate for their needs is referred to as the appropriateness recognizability of a product or system.

\myparagraph{Learnability}
One of the sub-characteristics of usability is the learnability of a product or system. We define this as the degree to which a product or system can be used by specified users to achieve specified goals or learning to use the product or system with effectiveness, efficiency, freedom from risk and satisfaction in a specified context of use.

\myparagraph{Operability}
The fourth sub-characteristic of usability is operability. The operability of a product or system defines the degree to which it has attributes that make it easy to operate and control.

\myparagraph{User error protection}
The next sub-characteristic defines the degree to which a system protects users against making errors. We refer to this as user error protection.

\myparagraph{User interface aesthetics}
Finally, the sub-characteristic user interface aesthetics defines the degree to which a user interface enables pleasing and satisfying interaction for the user.

\subsection{Overview}
As mentioned, not all (sub-) characteristics of the ISO 25010 will be measured in this research. The most important characteristics for us are maintainability and performance efficiency, whilst the others are either less important or not suitable for this research. See table \ref{table:overview} for an overview of all characteristics.

\begin{table}[H]
\centering
\caption{ISO 25010 characteristics overview}
\label{table:overview}
\begin{tabular}{ll}
\multicolumn{1}{l|}{\textbf{Characteristic}} & \textbf{Measured in research} \\ \hline
\multicolumn{1}{l|}{Compatibility}           & No                            \\
\multicolumn{1}{l|}{Functional suitability}  & No                            \\
\multicolumn{1}{l|}{Maintainability}         & Yes                           \\
\multicolumn{1}{l|}{Performance efficiency*} & Yes                           \\
\multicolumn{1}{l|}{Portability}             & No                            \\
\multicolumn{1}{l|}{Reliability}             & No                            \\
\multicolumn{1}{l|}{Security}                & No                            \\
\multicolumn{1}{l|}{Usability}               & No                            \\
*Except for capacity                         &                              
\end{tabular}
\end{table}

\chapter{Research}
Since the main goal of this research is to find differences between modular and non-modular programs, it is important that we are able to define whether a program is modular or not. Thus, one of the main problems to tackle is the categorization of programs by measuring their modularity.\\

After the programs have been categorized, they have to be measured on the different characteristics defined in the ISO/IEC 25010 standard. In this research we will focus on maintainability and performance efficiency measurements, as seen in table \ref{table:overview}.

\section{Methodology}
\subsection{Criteria}
In this research we limit ourselves to some degree. First of all, we will only use projects with less than 100k lines. Secondly, we will not use any files that are empty, nor will we use any test files or files place inside test directories. For this exclusion, we assume that test files will either have 'test' in their name, or are situated in a place where a parent folder contains the word 'test' in its name. Besides this we will also ignore files that produce an error while being evaluated. If a big part of all files within a project produce errors, and are thus discarded, we will discard the entire project since we would not be able to give an accurate result for the entire program.

\subsection{Program analysis}
In order to analyze each project, we will have to make use of different analyzing methods. Some aspects, such as performance, require a program to be executed. Other characteristics of a program, for example code volume or complexity, do not require execution.

\myparagraph{Dynamic program analysis}
Dynamic program analysis is the analysis of software performed by executing the program on a real or virtual processor. In order to get accurate and effective results, dynamic program analysis should be performed multiple times.

\myparagraph{Static program analysis}
Static program analysis is the analysis of software performed without executing the program. This form of program analysis is performed on the source code of a program and can give insight in aspects like volume, complexity and modularity (which we will cover below).

\subsection{Modularity}
In order to measure the modularity of a program correctly, we will have to measure different aspects of a program. We can use the two main characteristics of a module, low couping and high cohesion, to do so. Since these characteristics tell us something about the dependencies within a program, measuring the dependencies between modules would be an accurate representation of the modularity.

\myparagraph{Measuring dependencies of a module}
Dependencies exist in many forms, such as (imported) variables and constants, but mainly function calls and class definitions. Even though variables or constants used from other modules are also dependencies, we do not consider these relevant in this research. In order to measure the modularity of a module, we will look at the function calls that exist within the module. We categorize these function calls into internal and external function calls. The first being function calls made to functions within the module itself, while the latter are calls to functions outside of the current module. Once we have gathered all function calls, and categorized them into their respective groups, we can calculate the modularity. We calculate the modularity of a module with the following formula:

\[ modularity = \dfrac{internal\ calls}{all\ calls} \]

This will give us a percentage that represents the modularity of the tested module. After doing this for all modules within a program, which in Python would be every single file, we can calculate the modularity for the entire program by taking the average of all separate modules.

\myparagraph{Validating the categorization}
It is important that the categorization of programs is correct, since any mistake could have a substantial impact on the outcome of the research. In order to validate the categorization mentioned above, we will compare the outcomes of the categorizations to that of Better Code Hub\cite{BetterCodeHub} and the method using the Modularity Index\cite{emanuel2013modularity}.

Better Code Hub is a tool developed by the Software Improvement Group\cite{SIG} which benchmarks a piece of software on their ten guidelines for maintainable software. One of these guidelines is 'Separate concerns in modules', which defines the modularity of a program. In order to measure this, Better Code Hub looks at the number of incoming calls to a module, which is then compared to the guideline values.
\todo[inline]{Remove this because it is also explained in the related work section??? If not: add explanation of Modularity Index}

We will validate our method of classifying programs using a number of Python repositories. By using repositories that are somewhat the same in functionality we try to make the validation more accurate and more representative. During these tests we categorized a program as being modular when the modularity score exceeded the used threshold of 0.575 (or 57.5\%), which was deemed to be the optimal threshold.

\subsection{Maintainability}
One of the main code quality characteristics is maintainability. As we have seen, maintainability can be split into the sub-characteristics analysability, modifiability, modularity, re-usability and testability. In order to compute the maintainability score for a program, we will have to first calculate all sub-characteristic scores. In order to calculate these we will use a weighted average of scores from other, even more defined, sub-characteristics of software, as proposed by the Software Improvement Group\cite{heitlager2016practical}, see table \ref{table:maintainability-weights}.
\todo[inline]{Move original SIG table to background and related work (since it is changed) and add explanation}

\begin{table}[H]
\centering
\caption{Maintainability characteristics and calculation weights}
\label{table:maintainability-weights}
\begin{tabular}{llllll}
                        & \textbf{Analysability} & \textbf{Changeability} & \textbf{Modularity} & \textbf{Re-usability} & \textbf{Testability} \\
\textbf{Complexity}     & -                      & 4                      & -                   & 3                     & 4                    \\
\textbf{Duplication}    & 3                      & 3                      & -                   & -                     & -                    \\
\textbf{Function calls} & -                      & -                      & 1                   & -                     & -                    \\
\textbf{Modularity}     & -                      & 2                      & -                   & -                     & -                    \\
\textbf{Stability}      & -                      & -                      & -                   & 2                     & -                    \\
\textbf{Test coverage}  & 1                      & -                      & -                   & -                     & 1                    \\
\textbf{Unit size}      & 2                      & -                      & -                   & 1                     & 2                    \\
\textbf{Volume}         & 5                      & -                      & -                   & 1                     & -                   
\end{tabular}
\end{table}

In order to measure each sub-characteristic defined above, we will use the model provided by the Software Improvement Group\cite{heitlager2016practical} as a guideline, however, we have adapted this slightly to fit our needs the best. The metrics that we will use for each sub-characteristic can be found in appendix \ref{appendix:maintainability_metrics}. After calculating the scores for each sub-characteristic with these metrics, we can calculate the score for each maintainability characteristic using the weighted average of a set of sub-characteristics, as defined above.\\

Once we have computed the scores for each of the maintainability characteristics, we can use these to find the maintainability score for a program using the formula defined below.

\[ Maintainability\ Score = \dfrac{3 * AS + 2 * CS + MS + 2 * RS + 2 * TC}{10} \]

Where:\\
$AS$ = Analysability Score\\
$CS$ = Changeability Score\\
$MS$ = Modularity Score\\
$RS$ = Re-usability Score\\
$TS$ = Testability Score\\
\\
This formula is based off of the metric defined by the Software Improvement Group, as seen in figure \ref{figure:maintainability_weights}. Since that model uses the ISO/IEC 9126 definition of maintainability, it is slightly adapted and extended. The metric we use uses the weight ratios for analysability and testability as defined in their work. We extended this by also applying the weight of testability to the changeability and re-usability scores, since they are of the same importance in maintainability. Finally, since modularity is part of maintainability in the ISO/IEC 25010 standard, we added this to the formula. Since we are looking at the relation between modularity and maintainability, the weight of modularity in this formula is kept low since it would show a positive correlation between the two if we did not.

\subsection{Performance efficiency}
Performance efficiency consists of three sub-characteristics: capacity, resource utilization and time behavior. For our research we will discard capacity and only focus on resource utilization and time behavior during normal execution. In order to measure these performance characteristics we will make use of dynamic program analysis. We will make eight Python web crawlers perform the same action on a web page for 100 iterations. After these iterations we are able to take the average time taken for each tool and compare that to the modularity score of each program. We will make all crawlers extract the first input element, or somethings similar, from the Google homepage (https://google.com) in each iteration.\\

In order to measure the resource utilization we will run each program with the built-in time module of Ubuntu. This will give us some statistics about the execution, we will use the memory usage statistic to plot the resource utilization of each program.

\chapter{Experimental setup}
Experiments will be done on projects of two programming languages: Python and Java. As we have seen above, some experiments require static program analysis, whilst others require dynamic program analysis. This requires us to use suitable projects that meet our requirements.

\section{Python experiments}
Our Python test suite consists of a total of 39 projects. These projects are all categorized and used in different experiments, below an overview of the experiments and used projects.

\myparagraph{Method validation}
In the modularity calculation method validation we will make use of 31 Python projects. These projects consist of nine micro web frameworks, seven cryptocurrency related projects and seven IoT projects. The remaining test projects are web crawlers.

\myparagraph{Modularity vs. Maintainability}
After the validation, 41 Python projects are used to do experiments on the relation between modularity and maintainability.

\myparagraph{Modularity vs. Performance efficiency}
Measuring the differences in performance efficiency between multiple projects with a different modularity score requires a set of projects with the same functionality. Therefore the test suite will consist of 11 web crawlers written in Python.

\section{Java experiments}
\todo{Insert once Java test have been executed}

\section{System specifications}
Whilst static program analysis is generally not influenced by the operating system or processor, dynamic program analysis does get affected by the system specifications. All experiments have been executed on a laptop with the specifications seen in table \ref{table:specifications}.
\begin{table}[H]
\centering
\caption{System specifications used in this research}
\label{table:specifications}
\begin{tabular}{ll}
\textbf{Operating system:} & 64-bit Ubuntu 16.04 LTS    \\
\textbf{Processor:}        & Intel Core i7-4700MQ       \\
\textbf{Memory:}           & 8GiB SODIMM DDR3 (1600MHz) \\
\textbf{Cache levels:}     & 2565KiB (L1), 1Mib (L2), 6Mib (L3) \\
\end{tabular}
\end{table}

\chapter{Results}
\section{Modularity}
\myparagraph{Dependency measuring method validation}
As we can see in table \ref{table:validation}, our method produces the same result as the method using the Modularity Index in almost 75\% of all cases. Even though this isn't the ideal value, we can see that this percentage is almost the same for the Modularity Index vs. Better Code Hub approach. We can therefore conclude that even though our method doesn't fully align with neither the Modularity Index nor the Better Code Hub approach, it can be considered correct. One reason why we can say this is because of the flaws we found in both existing approaches. The flaw of the approach taken by Better Code Hub is that the main characteristics of a module are not taken in to account when computing the modularity (score). The Modularity Index, on the other hand, seems to be too complex, making it less reliable. This can be seen when looking at a formally fully modular program (for example a program with just one file in Python). When calculating the modularity using the Modularity Index approach this will produce a result stating that the program is not 100\% modular, even though it is. This is partially due to the fact that this method was originally developed for Java systems, which officially defines a module on a bigger scale than Python.

\begin{table}[H]
\centering
\caption{Method validation results on 31 Python repositories}
\label{table:validation}
\begin{tabular}{llll}
\textbf{}                         & \textbf{Own vs. MI} & \textbf{Own vs. BCH} & \textbf{MI vs. BCH} \\ 
\textbf{False positives}          & 4                   & 5                    & 2                   \\
\textbf{False negatives}          & 4                   & 8                    & 5                   \\
\textbf{Corresponding percentage} & 74.2\%              & 58.1\%               & 77.4\%             
\end{tabular}
\end{table}

\section{Maintainability}
Maintainability consists of five sub-characteristics, which were all calculated for each of the projects in our test set. For each of the sub-characteristics (excluding modularity) a scatter chart was created to visualize their relation to modularity and find a trend line supporting the results. The results for each sub-characteristic are discussed below.

\myparagraph{Analysability}
\begin{figure}[H]
    \caption{Modularity vs. Analysability results}
    \label{figure:mod-analysis}
    \centering
        \includegraphics[width=0.70\textwidth]{modularity-analysability}
\end{figure}

As we can see from figure \ref{figure:mod-analysis} there is almost no correlation between the modularity and analysability of a program. The results show us that most data-points follow the trend-line with no real outliers. Looking at the Pearson coefficient for this relation, we can see that the value of -0.163 indicates a slight negative correlation between the two characteristics.

\myparagraph{Changeability}
\begin{figure}[H]
    \caption{Modularity vs. Changeability results}
    \label{figure:mod-change}
    \centering
        \includegraphics[width=0.70\textwidth]{modularity-changeability}
\end{figure}

The results of this test, see in figure \ref{figure:mod-change}, show a clear positive correlation between modularity and changeability. With a Pearson coefficient of 0.457 this correlation is quite substantial. 

\myparagraph{Re-usability}
\begin{figure}[H]
    \caption{Modularity vs. Re-usability results}
    \label{figure:mod-reuse}
    \centering
        \includegraphics[width=0.70\textwidth]{modularity-reusability}
\end{figure}

Figure \ref{figure:mod-reuse} shows us that there is quite a large standard deviation in the re-usability scores of our test suite. The standard deviation we found is 0.525, which is less compact than the standard deviations of for example the analysability (0.207) and changeability (0.325). We can see a slight positive correlation between the modularity and re-usability of a program, which is supported by a Pearson coefficient of 0.137.

\myparagraph{Testability}
\begin{figure}[H]
    \caption{Modularity vs. Testability results}
    \label{figure:mod-test}
    \centering
        \includegraphics[width=0.70\textwidth]{modularity-testability}
\end{figure}

The relation between modularity and testability appears to be slightly positive. With a Pearson coefficient of 0.251 this correlation is stronger than that of the re-usability mentioned above, which also has a higher standard deviation. Figure \ref{figure:mod-test} shows the relation using our test suite.

\myparagraph{Overall}
\begin{figure}[H]
    \caption{Modularity vs. Maintainability results}
    \label{figure:mod-main}
    \centering
        \includegraphics[width=0.65\textwidth]{modularity-maintainability}
\end{figure}

If we combine these results using a weighted average we get the overall maintainability scores, see figure \ref{figure:mod-main}. As we can see, an increased degree of modularity causes the maintainability to also increase. Using these results we can say that modularity has a positive effect on the maintainability of a program. With a Pearson coefficient of 0.521 this correlation is really strong, without having many outliers.

\myparagraph{Overview}
Table \ref{table:main-overview} contains the results for all tested characteristics involved with maintainability. We can see that most relations show a positive Pearson coefficient, except for analysability. Since the standard deviation is quite low for most relations, the correlation results are quite strong and could be applied to a more broad sense.

\begin{table}[H]
\centering
\caption{Overview of maintainability characteristic results}
\label{table:main-overview}
\begin{tabular}{lll}
                         & \textbf{Pearson Coefficient} & \textbf{Standard Deviation} \\
\textbf{Analysability}   & -0.163                       & 0.207                       \\
\textbf{Changeability}   & 0.457                        & 0.325                       \\
\textbf{Re-usability}    & 0.137                        & 0.525                       \\
\textbf{Testability}     & 0.251                        & 0.365                       \\
\textbf{Maintainability} & 0.521                        & 0.277                      
\end{tabular}
\end{table}

\section{Performance efficiency}
The two sub-characteristics of performance efficiency we have tested are resource utilization and time behavior. For both characteristics we calculated the relation to modularity and plotted the results in a scatter plot. The results are discussed below.

\myparagraph{Resource utilization}
\begin{figure}[H]
    \label{figure:perf-res}
    \caption{Modularity vs. Resource utilization results}
    \centering
        \includegraphics[width=0.65\textwidth]{modularity-resourceutilization}
\end{figure}

Figure \ref{figure:perf-res} shows that our data appears to be far apart. With a standard deviation of over 13000kb we can conclude that the differences between are very large, no matter the modularity score. However, with a Pearson coefficient of 0.287 we can see that there is positive correlation between the modularity and resource utilization of a program.

\myparagraph{Time behavior}
\begin{figure}[H]
    \label{figure:perf-time}
    \caption{Modularity vs. Time behavior results}
    \centering
        \includegraphics[width=0.65\textwidth]{modularity-timebehavior}
\end{figure}

The results seen in figure \ref{figure:perf-time} show that there is almost no correlation between modularity and execution speed. We can see that there is one big outlier which influences the data a lot. With this data point included we get a Pearson coefficient of just -0.015, and a standard deviation of 0.497. However, if we would remove this outlier, we get the results shown in figure \ref{figure:perf-time-no}. This figure shows all execution differences on a smaller scale. Using these results we get a Pearson coefficient of 0.169, which indicates a slightly positive correlation between the characteristics.

\begin{figure}[H]
    \label{figure:perf-time-no}
    \caption{Modularity vs. Time behavior results (without outlier)}
    \centering
        \includegraphics[width=0.65\textwidth]{modularity-timebehavior-nooutlier}
\end{figure}

\myparagraph{Overview}
Table \ref{table:perf-overview} contains the results for all performance efficiency characteristics that we have tested. We can see that the relations are both positive, meaning that a more modular program is likely to use more memory and take more time to execute.

\begin{table}[H]
\centering
\caption{Overview of performance efficiency characteristics results}
\label{table:perf-overview}
\begin{tabular}{lll}
                              & \textbf{Pearson Coefficient} & \textbf{Standard Deviation} \\
\textbf{Resource Utilization} & 0.287                        & 13183                       \\
\textbf{Time Behavior}        & 0.169                        & 0.099                      
\end{tabular}
\end{table}

\chapter{Discussion}
We have measured two main characteristics and their sub-characteristics from the ISO/IEC 25010 standard: maintainability and performance efficiency. By plotting them against the modularity of the programs used we are able to find correlations between them.

\myparagraph{Modularity vs. Maintainability}
The results show that there is in fact a positive correlation between the modularity and maintainability of a program. Whilst not all sub-characteristics of maintainability show a positive correlation with modularity, the overall results show a Pearson coefficient of 0.537, indicating a strong correlation between the two. Thus, we can say that modularity has a positive effect on the maintainability of a program. The reason why the analysability of a program is negatively influenced by the modularity might be because a more modular program might contain more files, making it harder to analyze all functionality. Though this is just speculation.

\myparagraph{Modularity vs. Performance Efficiency}
When looking at the effect of modularity on the resource utilization and time behavior of a program, we can see that in both cases there is a slight positive correlation between the two. However, the Pearson coefficient values of 0.287 and 0.169 respectively indicate that a more modular program is likely to use more memory than a less modular program, as well as take longer to execute. This might also be due to the fact that a single module (file) might contain more code, since all functionality is grouped together according to the definition of a module. This could also be a cause for the increase in execution time, since it will take longer to execute a bigger program. Overall we can say that modularity has a negative effect on the performance efficiency of a program since a positive correlation is present. 

\chapter{Related Work}
As we can conclude from other researches\cite{LinuxKernel,lee2000linux},modularity allows for more collaborative software development, and makes it easier to find and resolve bugs. However, we are curious whether modularity has any effect on the quality of software, something which cannot be determined from the above. Research has been done on this matter already\cite{stamelos2002code}. In this research, 100 open source C applications were investigated on different quality metrics. As a result, a clear relationship between high modularity and software quality was found. Whilst this follows our hypothesis, there are a few flaws to this research from our point of view. The main flaw is that the metrics used to define the quality of a program only covers a portion of all characteristics that are present in the ISO/IEC 25010 standard on software quality\cite{ISO25010}. Besides this, the research was focused on open source C applications, while our research focuses on (open source) Python applications.

\subsection*{Measuring modularity}
There are already some methods to measure modularity, one of these methods is to only look at the coupling between modules\cite{BetterCodeHub,visser2016building}. This method looks at the number of incoming calls to a module. This way all external module dependencies will be evaluated to determine the modularity. However, the flaw to this method is that only incoming calls are evaluated, whilst outgoing calls provide a better insight into the dependencies of a module. It is also the case that the cohesion within a module is neglected, even though this shows how all components within a module are connected.

\myparagraph{Modularity Index}
In another research regarding modularity, metrics have been created in order to specify the modularity of (open source) Java programs\cite{emanuel2013modularity}. Since it has proven to be effective to use a modular software architecture in open source projects, they tried to find a clear metric to justify this. To do this they focused on Java applications, making it somewhat unsuitable for our research. In their metric, an application consists of three layers: classes, packages and systems. Using the modularity that these layers produce, the modularity index can be computed, which defines the modularity of a program. There are however, a few flaws in this approach. First of all, when looking at class level modularity (which in turn influences the other layers) we can see that more metrics are used than just the two core modularity characteristics. This might have an unwanted effect on the outcome of our tests, since a simple program contained in a single module is not seen as fully modular using this approach, even though it follows the module guidelines. This might be due to the fact that in Java a module is of larger scale than in Python. Secondly, the main characteristics of a module (cohesion and coupling) are not seen as the most important factors when computing the modularity of a program. In fact, coupling isn't taken into account at all.

\subsection*{Measuring maintainability}
The predecessor of the ISO/IEC 25010 standard is the ISO/IEC 9126 standard\cite{ISO9126}. This standard also provided a list of software quality characteristics and their sub-characteristics. Researchers have developed a model for measuring the maintainability of a program using the ISO/IEC 9126 definition of maintainability\cite{heitlager2016practical}. They provided a number of metrics that can be used to calculate the sub-characteristics of maintainability, and the maintainability of a program itself. We make use of these metrics by adapting and extending them to fit the ISO/IEC 25010 standard's definition of maintainability. The original metrics can be found in appendix \ref{appendix:maintainability_metrics}.

\chapter{Conclusion}
\todo{20\%intro, 80\%bragging of what you did}

\bibliographystyle{IEEEtran}
\bibliography{refs}

\begin{appendices}
\chapter{Maintainability metrics}
\label{appendix:maintainability_metrics}
\todo[inline]{Add metrics from \cite{heitlager2016practical}}
\begin{figure}[H]
    \label{figure:maintainability_weights}
    \caption{ISO/IEC 9126 maintainability metric}
    \centering
        \includegraphics[width=0.70\textwidth]{maintainability_weights}
\end{figure}

\end{appendices}

\end{document}
