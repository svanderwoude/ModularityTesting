\documentclass[twoside]{uva-inf-bachelor-thesis}
%\usepackage[dutch]{babel}

% Filling your thesis with only lorem ipsum is not advised.
\usepackage{lipsum}
\usepackage{todonotes}
\usepackage{cite}
\usepackage{amsmath}
\usepackage{float}
\usepackage[toc,page]{appendix}

\newcommand{\myparagraph}[1]{\paragraph{#1}\mbox{}\\}

% Title Page
\title{The effect of modularity on software quality}
\author{Stefan van der Woude}
\supervisors{dr. A.M. Oprescu}
\signedby{Signees}

\begin{document}
\maketitle

\begin{abstract}

\end{abstract}

\tableofcontents


\chapter{Introduction}
\todo{Remove time references everywhere}
Creating high quality software is often very difficult, and becomes even harder when the size increases. Over the years, many standards and guidelines have been developed to provide general definitions and rules for software. Examples of this are the Don't Repeat Yourself (DRY) concept, cyclomatic complexity metric and test coverage measurements. Even though there are in many cases clear quantitative guidelines for these values and concepts, they are hard to strictly follow in complex programs.\\

If we look at a more general view of software, we get to the field of software design. Software design is the process by which an agent creates a specification of a software artifact, intended to accomplish goals, using a set of primitive components and subject to constraints. One of these design techniques is modular programming, which we will analyze in this thesis. Modular programming emphasizes separating the functionality of a program into independent, interchangeable modules, such that each contains everything necessary to execute only on aspect of the desired functionality. In this paper a method of measuring the degree of modularity of a program is developed, after which a set of programs is tested on different quality characteristics, including modularity.

\section{Research questions}
The goal of this research is to find if there is a relation between the degree of modularity of a program and the quality of that program. Using the tests described above we will be able to get an overview of the effect of modularity on the different quality characteristics. The research question that we want to answer is as follows:

\[ \text{"What is the effect of modularity on the quality of software?"} \]

In order to answer this question we will have to answer a few other questions. Since we have to define the degree of modularity of programs, we will have to answer the question "How can we easily and effectively calculate the degree of modularity of a program?". After this question has been answered, we have to find methods for measuring all (sub-) quality characteristics used to define the quality of software. Thus, for each characteristic we have to find an answer to the question "How can we measure [quality attribute] of a program?". The answers to these questions will create a framework to perform measurements on a program, after which the main research question can be answered.

\section{Research methodology}
\todo{see PAV}

\section{Thesis outline}

\chapter{Background}
Writing good code is something you are taught to achieve from the day you start learning programming. Code quality is often seen as something really important, it assures that the software is maintainable and fast. Quality could be seen as not having any bad practises in your code base, since one might think that will improve the maintainability of the code. However, research has shown that these code smells do not necessarely have a negative (nor a positive) effect on maintainability\cite{sjoberg2013quantifying}. Something that might be of interest when looking at maintainability is consistency. Together with code size, this might improve the readability and analysability of software.

\section{Software design}
One way to force some level of consistency within a program is the use of a software design pattern. These patterns, or techniques, describe the design of the design: how will the program be structured? Edsger W. Dijkstra referred to this layering of semantic levels as the "radical novelty" of computer programming\cite{dijkstra1988}. In this thesis we focus on the Modular Programming design technique.

\subsection{Modular programming}
Modular programming is a software design technique that emphasizes separating the functionality of a program into independent, interchangeable modules, such that each contains everything necessary to execute only one aspect of a desired functionality. Not all programming languages formally support the concept of modules, languages like C\#\cite{csharpmodules}, Java\cite{javamodules} and Python\cite{pythonmodules} do.\\

In 1975 Fred Brooks observed that there is a positive correlation between the size of an organization and the delay in time to market, we call this Brooks' Law \cite{brooks1975mythical}. Brooks argued that adding more programmers to a software project that is already at a late stage of the development process further delays the project. He reasoned that the complexity and communication cost of a project increase with the square of the number of developers, but the amount of work done only rises linearly \cite{lee2000linux}.\\

This problem also occurred in the development of the Linux Kernel, which is an open source project \cite{LinuxKernel}. In 1996 the creator, Linus Torvalds, decided to move towards a modular software architecture which would allow him to set boundaries within which the developers of each module have full control over implementation and design details. This architecture countered Brooks' Law and allowed a large group of people to develop a computer program jointly. Torvalds stated that "without modularity, I would have to check every file that changed, which would be a lot, to make sure nothing was changed that would affect anything else. With modularity, when someone sends me patches to do a new file system and I don't necessarily trust the patches per se, I can still trust the fact that if nobody's using this file system, it's not going to impact anything else." \cite{lee2000linux}. Another study, on the Apache and Mozilla projects also showed that high modularity (together with many bug finders and fixers) resulted in low defect densities and allowed for faster development.\\

\myparagraph{What is a module?}
Formally, a module is seen as a self-contained piece of software that contains everything necessary to execute only one aspect of a more broad functionality.\\

By this definition we can already see that this could be interpreted in many different ways. It is worth noting that even though the languages above support modules, the exact definition can still differ per language. For example, in Python each file is seen as a module, while in Java a module is a collection of packages. Thus, even though all languages use the same definition of a module, the scale of the term varies between them.

\myparagraph{Characteristics of modules}
Since a module is a self-contained piece of software, it is important that it has as few dependencies to other software as possible. The degree of interdependence between modules is called coupling, which should be low in the case of a perfect module. Since there are almost no dependencies to other modules, it is important that the module itself can perform its functionality itself. Making sure that all functionality within the module is tied together and belongs to each other is a second requirement of the ideal module. We refer to the degree to which elements inside a module belong together as cohesion, which should be high in the case of a perfect module.\\

Besides these main characteristics of modules, on could also argue that another characteristic of a module is that it is a part of software that can be reused in multiple conditions, which would mean that a single function could also be seen as a (small-scale) module. In this thesis we will stick with the original characteristics to do measurements.

\section{Software quality}
Software quality might be somewhat an opinion, it strongly depends on your own interpretation of a program. However, in 2011, the International Organization for Standardization released the ISO/IEC 25010 - 'System and software quality models' standard\cite{ISO25010} which defines a set of models and characteristics to test software quality. This standard is a successor to the ISO/IEC 9126 - 'Product quality - Quality model' standard\cite{ISO9126} released in 2001.

\subsection{ISO/IEC 25010}
The ISO/IEC 25010 standard defines eight characteristics that can be evaluated when looking at the quality of a piece of software. Some of these relate to the outcome of interaction when a product is used in a particular context of use, others relate to the static properties of software and dynamic properties of the computer system it is used in. The full list of characteristics and their sub-characteristics is listed below.

\subsection{Compatibility}
The first quality characteristic is compatibility. Compatibility is referred to as the degree to which a product, system or component can exchange information with other products, systems or components, and/or perform its required functions, while sharing the same hardware or software environment. We can divide this into two sub-characteristics: co-existence and interoperability. In our research we will not look at this characteristic since it is not likely to be affected by modularity.

\myparagraph{Co-existence}
The first sub-characteristic is co-existence. Co-existence is the degree to which a product can perform its required functions efficiently while sharing a common environment and resources with other products without detrimental impact on any other product.

\myparagraph{Interoperability}
The interoperability of two or more systems, products or component defines the degree to which they can exchange information and use the information that can be exchanged.

\subsection{Functional suitability}
The second quality characteristic is functional suitability, this characteristic defines the degree to which a product or system provides functions that meet stated and implied needs when used under specified conditions. This characteristic consists of three sub-characteristics: functional appropriateness, functional completeness and functional correctness. We will not look at the functional suitability of our test programs since the functionality does not rely on the modularity of a program.

\myparagraph{Functional appropriateness}
The functional appropriateness of a system defines the degree to which the set of functions facilitate the accomplishment of specified tasks and objectives.

\myparagraph{Functional completeness}
The second sub-characteristic defines the degree to which the set of functions in a system covers all the specified tasks and user objectives. We call this the functional completeness of a product or system.

\myparagraph{Functional correctness}
The functional completeness of a product or system defines the degree to which it provides the correct results with the needed degree of precision.

\subsection{Maintainability}
The next characteristic, after functional suitability, is maintainability. Whilst maintainability could be evaluated differently per person, there are some aspects of a program that can be measured to determine the maintainability of a program. In this case we refer to maintainability as the degree of effectiveness and efficiency with which a product or system can be modified to improve it, correct it, or adapt to changes in environment, and in requirements. This characteristic consists of four aspects. We will look at the relation between modularity and maintainability since the software design method of a system can have effect on the maintainability of the system.

\myparagraph{Analysability}
Analysability is the degree of effectiveness and efficiency with which it is possible to assess the impact on a product or system of an intended change to one or more of its parts, or to diagnose a product for deficiencies or causes of failures, or to identify parts to be modified.

\myparagraph{Modifiability}
The second sub-characteristic, modifiability, is referred to as the degree to which a product or system can be effectively and efficiently modified without introducing defects or degrading existing product quality.

\myparagraph{Modularity}
Whilst we are looking at the effect of modularity on the quality of software, ISO/IEC 25010 already considers this to have an effect on the maintainability of a product or system.

\myparagraph{Re-usability}
With re-usability, we refer to the degree to which an asset can be used in more than one system, or in building other assets.

\myparagraph{Testability}
The final sub-characteristic of maintainability is testability. Testability defines the degree of effectiveness and efficiency with which test criteria can be established for a system, product or component and tests can be performed to determine whether those criteria have been met.

\subsection{Performance efficiency}
The fourth characteristic, performance efficiency, presents the performance relative to the amount of resources used under stated conditions. This means that three components of performance and resources have to be tested. Performance efficiency is likely to be affected by the modularity of a program, though it might not be much. We will look at the relation between modularity and performance efficiency to support this.

\myparagraph{Capacity}
The first component is capacity, capacity is defined as the degree to which the maximum limits of a product or system parameter meets the requirements. We will ignore this sub-characteristic since the capacity of a program is arbitrary.

\myparagraph{Resource utilization}
Next, performance efficiency contains the sub-characteristic resource utilization. With resource utilization we mean the degree to which the amounts and types of resources used by a product or system, when performing its functions, meet the requirements.

\myparagraph{Time behavior}
The final component to look at is the degree to which the response and processing times and throughput rates of a product or system, when performing its functions, meet the requirements. We refer to this as the time behavior of a product or system.

\subsection{Portability}
The next characteristic defines the degree of effectiveness and efficiency with which a system, product or component can be transferred from one hardware, software or other operational or usage environment to another. We call this characteristic the portability of a system, product or component. When defining the portability, we can look at three different sub-characteristics: adaptability, installability and replaceability. Even though portability might be influenced by the modularity of a system, we will not look at this characteristic in this research due to the importance of others.

\myparagraph{Adaptability}
With adaptability, we refer to the degree to which a product or system can effectively and efficiently be adapted for different or evolving hardware, software or other operation or usage environments.

\myparagraph{Installability}
The second sub-characteristic defines the degree of effectiveness and efficiency with which a product or system can be successfully installed and/or uninstalled in a specified environment. We refer to this as the installability of a product or system.

\myparagraph{Replaceability}
The final sub-characteristic, replaceability, defines the degree to which a product can replace another specified product for the same purpose in the same environment.

\subsection{Reliability}
The next quality characteristic is reliability. With reliability we refer to the degree to which a system, product or component performs specified functions under specified conditions for a specified period of time. We can split this into four smaller characteristics. The reliability of a system does not depend on the software design used, thus we shall not look at the relation between the modularity and reliability of a program.

\myparagraph{Availability}
With availability we refer to the degree to which a system, product or component is operational and accessible when required for use.

\myparagraph{Fault tolerance}
The second characteristic defines the degree to which a system, product or component operates as intended despite the presence of hardware or software faults. We call this characteristic the fault tolerance of a system, product or component.

\myparagraph{Maturity}
The next sub-characteristic is maturity. Maturity is defined as the degree to which a system, product or component meets needs for reliability under normal operation.

\myparagraph{Recoverability}
The final sub-characteristic, recoverability, defines the degree to which, in event of an interruption or failure, a product or system can recover the data directly affected and re-establish the desired state of the system.

\subsection{Security}
The seventh quality characteristic defines the degree to which a product or system protects information and data so that persons or other products or systems have the degree of data access appropriate to their types and levels of authorization. We call this characteristic security. This can in turn be divided into five sub-characteristics such as confidentiality and integrity. Modularity does not have an effect on the security measures implemented in a piece of software, therefore we will ignore this characteristic in this research.

\myparagraph{Accountability}
The first sub-characteristic is accountability. Accountability shows the degree to which the actions of an entity can be traced uniquely to the entity.

\myparagraph{Authenticity}
Next up we define the degree to which the identity of a subject or resource can be proven to be the one claimed. We refer to this as authenticity.

\myparagraph{Confidentiality}
In a product or system, confidentiality is very important. The confidentiality of a product or system defines the degree to which it ensures that data is accessible only to those authorized to have access.

\myparagraph{Integrity}
The degree to which a system, product or component prevents unauthorized access to, or modification of, computer programs or data is referred to as integrity, which is the fourth sub-characteristic of security.

\myparagraph{Non-repudiation}
The final sub-characteristic is non-repudiation. This characteristic defines the degree to which actions or events can be proven to have taken place, so that events or actions cannot be repudiated later.

\subsection{Usability}
The final characteristic in the ISO 25010 standard is usability. Usability defines the degree to which a product or system can be used by specified users to achieve specified goals with effectiveness, efficiency and satisfaction in a specified context of use. We can split this into the six sub-characteristics defined below. This characteristic mainly depends on the User Experience of a program, since we will not cover this topic we will not look if there is a relation between modularity and User Experience.

\myparagraph{Accessibility}
The first sub-characteristic is accessibility. With accessibility we define the degree to which a product or system can be used by people with the widest range of characteristics and capabilities to achieve a specified goal in a specified context of use.

\myparagraph{Appropriateness recognizability}
The degree to which users can recognize whether a product or system is appropriate for their needs is referred to as the appropriateness recognizability of a product or system.

\myparagraph{Learnability}
One of the sub-characteristics of usability is the learnability of a product or system. We define this as the degree to which a product or system can be used by specified users to achieve specified goals or learning to use the product or system with effectiveness, efficiency, freedom from risk and satisfaction in a specified context of use.

\myparagraph{Operability}
The fourth sub-characteristic of usability is operability. The operability of a product or system defines the degree to which it has attributes that make it easy to operate and control.

\myparagraph{User error protection}
The next sub-characteristic defines the degree to which a system protects users against making errors. We refer to this as user error protection.

\myparagraph{User interface aesthetics}
Finally, the sub-characteristic user interface aesthetics defines the degree to which a user interface enables pleasing and satisfying interaction for the user.

\subsection{Overview}
As mentioned, not all (sub-) characteristics of the ISO 25010 will be measured in this research. The most important characteristics for us are maintainability and performance efficiency, whilst the others are either less important or are not suitable for this research. See table \ref{table:overview} for an overview of all characteristics.

\begin{table}[H]
\centering
\caption{ISO 25010 characteristics overview}
\label{table:overview}
\begin{tabular}{ll}
\multicolumn{1}{l|}{\textbf{Characteristic}} & \textbf{Measured in research} \\ \hline
\multicolumn{1}{l|}{Compatibility}           & No                            \\
\multicolumn{1}{l|}{Functional suitability}  & No                            \\
\multicolumn{1}{l|}{Maintainability}         & Yes                           \\
\multicolumn{1}{l|}{Performance efficiency*} & Yes                           \\
\multicolumn{1}{l|}{Portability}             & No                            \\
\multicolumn{1}{l|}{Reliability}             & No                            \\
\multicolumn{1}{l|}{Security}                & No                            \\
\multicolumn{1}{l|}{Usability}               & No                            \\
*Except for capacity                         &                              
\end{tabular}
\end{table}

\chapter{Research}
Since the main goal of this research is to find differences between modular and non-modular programs, it is important that we are able to define whether a program is modular or not. Thus, one of the main problems to tackle is the categorization of programs by measuring their modularity.\\

After the programs have been categorized, they have to be measured on the different characteristics defined in the ISO/IEC 25010 standard. In this research we will focus on maintainability and performance efficiency measurements, as seen in table \ref{table:overview}.

\section{Methodology}
\subsection{Criteria}
In this research we limit ourselves to some degree. First of all, we will only use projects with less than 100k lines. Secondly, we will not use any files that are empty, nor will we use any test files or files place inside test directories. For this exclusion, we assume that test files will either have 'test' in their name, or are situated in a place where a parent folder contains the word 'test' in its name. Besides this we will also ignore files that produce an error while being evaluated. If a big part of all files within a project produce errors, and are thus discarded, we will discard the entire project since we would not be able to give an accurate result for the entire program.

\subsection{Program analysis}
In order to analyze each project, we will have to make use of different analyzing methods. Some aspects, such as performance, require a program to be executed. Other characteristics of a program, for example code volume or complexity, do not require execution.

\myparagraph{Dynamic program analysis}
Dynamic program analysis is the analysis of software performed by executing the program on a real or virtual processor. In order to get accurate and effective results, dynamic program analysis should be performed multiple times.

\myparagraph{Static program analysis}
Static program analysis is the analysis of software performed without executing the program. This form of program analysis is performed on the source code of a program and can give insight in aspects like volume, complexity and modularity (which we will cover below).

\subsection{Modularity}
In order to measure the modularity of a program correctly, we will have to measure different aspects of a program. We can use the two main characteristics of a module, low couping and high cohesion, to do so. Since these characteristics tell us something about the dependencies within a program, measuring the dependencies between modules would be an accurate representation of the modularity.

\myparagraph{Measuring dependencies of a module}
Dependencies exist in many forms, such as (imported) variables and constants, but mainly function calls and class definitions. Even though variables or constants used from other modules are also dependencies, we do not consider these relevant in this research. In order to measure the modularity of a module, we will look at the function calls that exist within the module. We categorize these function calls into internal and external function calls. The first being function calls made to functions within the module itself, while the latter are calls to functions outside of the current module. Once we have gathered all function calls, and categorized them into their respective groups, we can calculate the modularity. We calculate the modularity of a module with the following formula:

\[ modularity = \dfrac{internal\ calls}{all\ calls} \]

This will give us a percentage that represents the modularity of the tested module. After doing this for all modules within a program, which in Python would be every single file, we can calculate the modularity for the entire program by taking the average of all separate modules.

\myparagraph{Validating the categorization}
It is important that the categorization of programs is correct, since any mistake could have a substantial impact on the outcome of the research. In order to validate the categorization mentioned above, we will compare the outcomes of the categorizations to that of Better Code Hub\cite{BetterCodeHub} and the method using the Modularity Index\cite{emanuel2013modularity}. Better Code Hub is a tool developed by the Software Improvement Group\cite{SIG} which benchmarks a piece of software on their ten guidelines for maintainable software. One of these guidelines is 'Separate concerns in modules', which defines the modularity of a program. In order to measure this, Better Code Hub looks at the number of incoming calls to a module, which is then compared to the guideline values.\\

\todo[inline]{Add explanation of Modularity Index}

We will validate our method of classifying programs using a number of Python repositories. By using repositories that are somewhat the same in functionality we try to make the validation more accurate and more representative. In order to validate our method, we will test it using nine Python web framework repositories, seven Python cryptocurrency-related projects, seven Python IoT projects and eight Python web crawlers. For each of the repositories we will calculate the modularity with our own method, and the method provided by Better Code Hub. The results of these tests can be seen in table \ref{table:validation}. During these tests we categorized a program as being modular when the modularity score exceeded the used threshold of 0.575 (or 57.5\%).

\begin{table}[H]
\centering
\caption{Method validation results on 31 Python repositories}
\label{table:validation}
\begin{tabular}{l|lll}
\textbf{}                         & \textbf{Own vs. MI} & \textbf{Own vs. BCH} & \textbf{MI vs. BCH} \\ \hline
\textbf{False positives}          & 4                   & 5                    & 2                   \\
\textbf{False negatives}          & 4                   & 8                    & 5                   \\
\textbf{Corresponding percentage} & 74.2\%              & 58.1\%               & 77.4\%             
\end{tabular}
\end{table}

\todo[inline]{Move results to 'Results'}
As we can see, our method produces the same result as the method using the Modularity Index in around 75\% of all cases. Even though this isn't the ideal value, we can see that this percentage is almost the same for the Modularity Index vs. Better Code Hub approach. We can therefore conclude that even though our method doesn't fully align with neither the Modularity Index nor the Better Code Hub approach, it can be considered correct. One reason why we can say this is because of the flaws we found in both existing approaches. The flaw of the approach taken by Better Code Hub is that the main characteristics of a module are not taken in to account when computing the modularity (score). The Modularity Index, on the other hand, seems to be too complex, making it less reliable. This can be seen when looking at a formally fully modular program (for example a program with just one file in Python). When calculating the modularity using the Modularity Index approach this will produce a result stating that the program is not 100\% modular, even though it is. This is partially due to the fact that this method was originally developed for Java systems, which defines a module on a bigger scale than Python.

\todo{Define how the ISO quality characteristics are tested.}
\subsection{Compatibility}

\subsection{Functional suitability}

\subsection{Maintainability}
One of the main code quality characteristics is maintainability. As we have seen, maintainability can be split into the sub-characteristics analysability, modifiability, modularity, re-usability and testability. In order to compute the maintainability score for a program, we will have to first calculate all sub-characteristic scores. In order to calculate these we will use a weighted average of scores from other, even more defined, sub-characteristics of software, as proposed by the Software Improvement Group\cite{heitlager2016practical}, see table \ref{table:maintainability-weights}.
\todo[inline]{Move original SIG table to background and related work (since it is changed) and add explanation}

\begin{table}[H]
\centering
\caption{Maintainability characteristics and calculation weights}
\label{table:maintainability-weights}
\begin{tabular}{l|lllll}
                        & \textbf{Analysability} & \textbf{Changeability} & \textbf{Modularity} & \textbf{Re-usability} & \textbf{Testability} \\ \hline
\textbf{Complexity}     & -                      & 4                      & -                   & 3                     & 4                    \\
\textbf{Duplication}    & 3                      & 3                      & -                   & -                     & -                    \\
\textbf{Function calls} & -                      & -                      & 1                   & -                     & -                    \\
\textbf{Modularity}     & -                      & 2                      & -                   & -                     & -                    \\
\textbf{Stability}      & -                      & -                      & -                   & 2                     & -                    \\
\textbf{Test coverage}  & 1                      & -                      & -                   & -                     & 1                    \\
\textbf{Unit size}      & 2                      & -                      & -                   & 1                     & 2                    \\
\textbf{Volume}         & 5                      & -                      & -                   & 1                     & -                   
\end{tabular}
\end{table}

In order to measure each sub-characteristic defined above, we will use the model provided by the Software Improvement Group\cite{heitlager2016practical} as a guideline, however, we have adapted this slightly to fit our needs the best. The metrics that we will use for each sub-characteristic can be found in appendix \ref{appendix:maintainability_metrics}. After calculating the scores for each sub-characteristic with these metrics, we can calculate the score for each maintainability characteristic using the weighted average of a set of sub-characteristics, as defined above.\\

Once we have computed the scores for each of the maintainability characteristics, we can use these to find the maintainability score for a program using the formula defined below.

\[ Maintainability\ Score = \dfrac{3 * AS + 3 * CS + MS + RS + 2 * TC}{10} \]

Where:\\
$AS$ = Analysability Score\\
$CS$ = Changeability Score\\
$MS$ = Modularity Score\\
$RS$ = Re-usability Score\\
$TS$ = Testability Score\\
\\
These weights are chosen by looking at the importance of each characteristic when defining maintainability. When thinking of maintainability, the most important things that come to mind are likely analysability and changeability, these characteristics define how easy it is to maintain a program. In order to make software more maintainable it is important that the software can be tested. Therefore we also apply a stronger weight to the testability. Even though modularity has an effect on the analysability and changeability of a program, we do not weigh it very heavily on its own, just like the re-usability of a program.
\todo[inline]{Add explanation of why these weights}

\subsection{Performance efficiency}
Performance efficiency consists of three sub-characteristics: capacity, resource utilization and time behavior. For our research we will discard capacity and only focus on resource utilization and time behavior during normal execution. In order to measure these performance characteristics we will make use of dynamic program analysis. We will make eight Python web crawlers perform the same action on a web page for 100 iterations. After these iterations we are able to take the average time taken for each tool and compare that to the modularity score of each program. We will make all crawlers extract the first input element from the Google homepage (https://google.com) in each iteration.\\

In order to measure the resource utilization we will run each program with the built-in time module of Ubuntu. This will give us some statistics about the execution, we will use the memory usage statistic to plot the resource utilization of each program.

\subsection{Portability}

\subsection{Reliability}

\subsection{Security}

\subsection{Usability}

\chapter{Experimental setup}
\todo{Update when finished completely}
Nine Python (micro) web frameworks.\\
Seven Python cryptocurrency-related projects.\\
Seven Python IoT projects.\\
Eight Python web crawlers.\\

\chapter{Results}
\section{Maintainability}
Maintainability consists of five sub-characteristics, which were all tested for the 31 projects mentioned before. For each of the sub-characteristics (excluding modularity) a scatter chart was created to visualize the results and find a trend line for supporting the results. These charts can be found in appendix \ref{appendix:maintainability_results}. These charts tell us that modularity does not have any substantial impact on the analysability of a program, whilst the other characteristics - changeability, re-usability and testability - do have a positive correlation with the degree of modularity. If we combine these results using a weighted average we get the overall maintainability scores, see figure \ref{figure:mod-main}. As we can see, an increased degree of modularity causes the maintainability to also increase. Using these results we can say that modularity has a positive effect on the maintainability of a program.

\begin{figure}[H]
    \label{figure:mod-main}
    \caption{Modularity vs. Maintainability results}
    \centering
        \includegraphics[width=0.65\textwidth]{modularity-maintainability}
\end{figure}

\section{Performance efficiency}
\subsection{Resource utilization}
Appears to be a relation - more modular = more memory usage. But not that many data points.
\begin{figure}[H]
    \label{figure:perf-res}
    \caption{Modularity vs. Resource utilization results}
    \centering
        \includegraphics[width=0.65\textwidth]{modularity-resourceutilization}
\end{figure}

\subsection{Time behavior}
No relation.
\begin{figure}[H]
    \label{figure:perf-time}
    \caption{Modularity vs. Time behavior results}
    \centering
        \includegraphics[width=0.65\textwidth]{modularity-timebehavior}
\end{figure}

\chapter{Discussion}
\todo{Answer research question; speculative :)}

\chapter{Related Work}
As we can conclude from other researches\cite{LinuxKernel,lee2000linux},modularity allows for more collaborative software development, and makes it easier to find and resolve bugs. However, we are curious whether modularity has any effect on the quality of software, something which cannot be determined from the above. Research has been done on this matter already\cite{stamelos2002code}. In this research, 100 open source C applications were investigated on different quality metrics. As a result, a clear relationship between high modularity and software quality was found. Whilst this follows our hypothesis, there are a few flaws to this research from our point of view. The main flaw is that the metrics used to define the quality of a program only covers a portion of all characteristics that are present in the ISO/IEC 25010 standard on software quality\cite{ISO25010}. Besides this, the research was focused on open source C applications, while our research focuses on (open source) Python applications.

\subsection*{Measuring modularity}
There are already some methods to measure modularity, one of these methods is to only look at the coupling between modules\cite{BetterCodeHub,visser2016building}. This method looks at the number of incoming calls to a module. This way all external module dependencies will be evaluated to determine the modularity. However, the flaw to this method is that only incoming calls are evaluated, whilst outgoing calls provide a better insight into the dependencies of a module. It is also the case that the cohesion within a module is neglected, even though this shows how all components within a module are connected.

\myparagraph{Modularity Index}
In another research regarding modularity, metrics have been created in order to specify the modularity of (open source) Java programs\cite{emanuel2013modularity}. Since it has proven to be effective to use a modular software architecture in open source projects, they tried to find a clear metric to justify this. To do this they focused on Java applications, making it somewhat unsuitable for our research. In their metric, an application consists of three layers: classes, packages and systems. Using the modularity that these layers produce, the modularity index can be computed, which defines the modularity of a program. There are however, a few flaws in this approach. First of all, when looking at class level modularity (which in turn influences the other layers) we can see that more metrics are used than just the two core modularity characteristics. This might have an unwanted effect on the outcome of our tests, since a simple program contained in a single module is not seen as fully modular using this approach, even though it follows the module guidelines. This might be due to the fact that in Java a module is of larger scale than in Python. Secondly, the main characteristics of a module (cohesion and coupling) are not seen as the most important factors when computing the modularity of a program. In fact, coupling isn't taken into account at all.

\chapter{Conclusion}
\todo{20\%intro, 80\%bragging of what you did}

\bibliographystyle{IEEEtran}
\bibliography{refs}

\begin{appendices}
\chapter{Maintainability metrics}
\label{appendix:maintainability_metrics}

\chapter{Maintainability testing sub-characteristics results}
\label{appendix:maintainability_results}
\begin{figure}[H]
    \caption{Modularity vs. Analysability results}
    \centering
        \includegraphics[width=0.70\textwidth]{modularity-analysability}
\end{figure}
\begin{figure}[H]
    \caption{Modularity vs. Changeability results}
    \centering
        \includegraphics[width=0.70\textwidth]{modularity-changeability}
\end{figure}
\begin{figure}[H]
    \caption{Modularity vs. Re-usability results}
    \centering
        \includegraphics[width=0.70\textwidth]{modularity-reusability}
\end{figure}
\begin{figure}[H]
    \caption{Modularity vs. Testability results}
    \centering
        \includegraphics[width=0.70\textwidth]{modularity-testability}
\end{figure}

\end{appendices}

\end{document}
